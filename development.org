* Planned features

- Identification & Authorization

  - [ ] Google Auth
  - (maybe) Jira auth

- Permission levels
  - Admin (can manager allowed domains and setup Oauth screens)
  - Manager (can manage teams)
  - User (can participate in the teams and meetings)

- Main screen
  - Some explanation what this is and what it does
  - Login button

- App screen (for logged in users)
  - User:
    - Join existing meeting
    - List past meetings
    - Personal actions - todo list
    - ⚙ user profile settings
      - avatar, username, etc

  - Manager
    - Create/start new meeting
      - Meeting description
      - ☑ Allow vote for topic
      - ☑ Sort topics by votes
      - Join URL (Google Meet, Zoom, etc)
    - Edit past meetings data (todo actions etc)
    - Activate/Deactivate (show/hide) past meetings data

  - Admin
    - ⚙ project settings link
      - Allowed domains list
      - Allowed oauth2 providers list

    - Permissions
    - Manage users

- Manage users - separate screen

  This screen will have breadcrums "Main -> Manage users"

  - List all users in a table with paginator
  - Make user inactive/active button
  - "Manage teams" button for each user
  - Information on actions (assigned/resolved)

- Meeting

  - Rounds:

    For each round - display the actual documentation at the other half of the screen, explaning roles & actions
    of people involved, to easy the process of onboarding to this new meeting structure.

    - Check-in round
    - Checklist review
    - Metrics review
    - +Project progress updates+ (Projects are not planned for 1st release)

  - Topics (tensions)
    - Add topic to discuss
      - added by user
      - topic title - string < 250 chars
      - topic votes
        - meeting participant can add vote to any topic of this meeting. we can store it as voted_by and then users list
          - need a function to add vote by user_id to topic_id
        - user can downvote any topic, but only one downvote per specific topic
        - For the topic we should store 'discussion notes' field
        - each topic results in zero or more actions.
        - action:
          - relation to meeting? or should we store actions within the meeting itself as cardinality: many? please decide the best
          - description
          - action can be assigned to (either):
            - assign to user
            - assign to team
          - deadline (date, optional)
          - action status:
            - added (timestamp)
            - completed (timestamp)
            - rejected (timestamp)

    - Voting for topic (if enabled)
    - Sorting topics by vote (if enabled)
    - Countdown timer (if enabled and set for topic)
    - Discussion phases: (traige issues)
      - Explanation (Raise Topic)
      - Questions round
      - Opinions round
      - Objections round
      - Acceptance (Decision round):
        - Accept or Decline
        - Secretary: write down the action items

  - Finalize:
    - Export as:
      - Doc
      - PDF
      - Directly to Confluence via API (if API is enabled)

* COMMENT Current work plan & progress [53%]

** DONE Set appropriate License
   CLOSED: [2025-06-15 Sun 21:30]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-06-15 Sun 21:30]
   - State "TODO"       from              [2025-06-15 Sun 20:15]
   :END:

** DONE Add all required modules
   CLOSED: [2025-06-15 Sun 21:20]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-06-15 Sun 21:20]
   :END:
   - [X] ring
   - [X] datastar sdk
   - [X] datastar js
   - [X] bulma
   - [X] selmer
   - [X] reitit/ring
   - [X] cider-nrepl
   - [X] nrepl

** DONE Home page and reload
   CLOSED: [2025-06-16 Mon 08:55]
   :LOGBOOK:
   - State "DONE"       from "DONE"       [2025-06-16 Mon 08:55]
   - State "DONE"       from "WORKING"    [2025-06-16 Mon 08:55]
   CLOCK: [2025-06-16 Mon 07:14]--[2025-06-16 Mon 08:55] =>  1:41
   - State "WORKING"    from "TODO"       [2025-06-16 Mon 07:15]
   :END:

- [X] Add home.html template
- [X] Add ring server handler, homepage view
- [X] Make sure code reload is working fine
- [X] Use bulma.css from CDN

** DONE Enable Datomic
   CLOSED: [2025-07-08 Tue 07:20]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-07-08 Tue 07:20]
   - State "TODO"       from              [2025-06-18 Wed 10:20]
   :END:
** DONE Fake login
   CLOSED: [2025-07-04 Fri 23:45]
   :LOGBOOK:
   - State "DONE"       from "WORKING"    [2025-07-04 Fri 23:45]
   CLOCK: [2025-06-29 Sun 14:19]--[2025-06-29 Sun 14:39] =>  0:20
   CLOCK: [2025-06-29 Sun 11:22]--[2025-06-29 Sun 11:49] =>  0:27
   CLOCK: [2025-06-28 Sat 12:34]--[2025-06-28 Sat 13:29] =>  0:55
   - State "WORKING"    from "DONE"       [2025-06-28 Sat 12:35]
   - State "DONE"       from "TODO"       [2025-06-27 Fri 09:05]
   - State "TODO"       from              [2025-06-23 Mon 03:55]
   :END:

I need fake login to quickly login several users for testing purposes on localhost.

 - [X] redirect from ~home~ to /app when user is logged in
 - [X] logout (remove all data from session)
 - [X] make 'fake login' page show previous users to choose
   - [X] fix fake login->login
   - [X] use datastar to fill random values instead of js
   - [X] add user when actually making login
   - [X] make separate page for fake login functionality

** DONE Create meeeting
   CLOSED: [2025-07-17 Thu 08:10]
   :LOGBOOK:
   - State "DONE"       from "WORKING"    [2025-07-17 Thu 08:10]
   - State "WORKING"    from              [2025-07-08 Tue 09:15]
   :END:

- [X] move to SSE
- [X] populate teams list
- [X] save data
- [X] for staff user - limit teams to member only
  - [X] for admin user - no limits

** DONE Make sure meetings are displayed for today
   CLOSED: [2025-08-13 Wed 08:30]
   :LOGBOOK:
   - State "DONE"       from "REJECTED"   [2025-08-13 Wed 08:30]
   - State "REJECTED"   from "DONE"       [2025-08-13 Wed 08:30]
   - State "DONE"       from "TODO"       [2025-08-13 Wed 08:30]
   CLOCK: [2025-08-13 Wed 08:29]--[2025-08-13 Wed 08:29] =>  0:00
   - State "TODO"       from              [2025-08-11 Mon 19:40]
   :END:

... No such problem as we display all 'active' meetings!

** TODO [#C] manage meetings [/]
   :LOGBOOK:
   - State "TODO"       from              [2025-07-26 Sat 13:00]
   :END:

 - [ ] meetings list
 - [ ] meeting "edit"
 - [ ] meeting settings/preferences button on the main meeting page
 - [ ] team admins manage
 - [ ] rename/change description
 - [ ] deactivate team

** DONE Prepare for meeting of [2025-08-29 Fri]
   CLOSED: [2025-08-29 Fri 11:55]
   :LOGBOOK:
   - State "DONE"       from "WORKING"    [2025-08-29 Fri 11:55]
   CLOCK: [2025-08-29 Fri 08:24]--[2025-08-29 Fri 11:54] =>  3:30
   CLOCK: [2025-08-29 Fri 08:02]--[2025-08-29 Fri 08:09] =>  0:07
   - State "WORKING"    from              [2025-08-29 Fri 08:00]
   :END:

 - [ ] +Join meeting - to be href!+ its a POST action, it can't be GET
 - [X] link to join meeting in recent meetings (join button)
 - [X] Fix issue with discussion notes
 - [X] why "past meetings" is not active ? We have 2 past meetings
 - [X] forbid access to finished meeting
 - [X] for the finished meeting, disable the topics swithing, adding actions, etc or think how to
 - [X] click on recent meetings should display
 - [X] Display discussion notes on past meetings/my actions
 - [ ] edit topic?
 - [ ] +negative action?+
 - [X] my actions - for me or for team?
 - [ ] problem with topic text
 - [X] topic description on join meeting

** TODO Finish playwright tests for the meeting screen
   :LOGBOOK:
   CLOCK: [2025-08-13 Wed 08:35]--[2025-08-13 Wed 09:00] =>  0:25
   - State "TODO"       from              [2025-08-11 Mon 19:40]
   :END:

*** Prepare data

**** TODO Make sure one active meeting per user exists
     :LOGBOOK:
     - State "TODO"       from              [2025-08-13 Wed 08:35]
     :END:

**** 

** DONE Small bugs to fix from [2025-08-13 Wed] [1/1]
   CLOSED: [2025-08-16 Sat 08:40]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-08-16 Sat 08:40]
   - State "TODO"       from              [2025-08-13 Wed 08:40]
   :END:

 - [X] delete topic - ask confirmation

** DONE Wally as UI tests of separate components
   CLOSED: [2025-08-16 Sat 08:55]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-08-16 Sat 08:55]
   - State "TODO"       from              [2025-08-06 Wed 00:20]
   :END:
*** DONE For testing applicaction in Clojure and Datomic - is there a way to run each test case in a clean database?
    CLOSED: [2025-08-16 Sat 08:55]
    :LOGBOOK:
    - State "DONE"       from              [2025-08-16 Sat 08:55]
    :END:

Does datomic provide a way to run this with in-memory database so its recreated fast?


Yes, absolutely. Datomic is excellent for this. You can use its *in-memory database*, which is recreated very quickly for each test.

The standard Clojure pattern is to use a =clojure.test= fixture. This fixture creates a fresh in-memory database, runs a single test, and then deletes the database.

Here is a complete, runnable example:

#+begin_src clojure
(ns my-app.core-test
  (:require [clojure.test :refer :all]
            [datomic.api :as d]))

;; A dynamic var to hold the connection for each test
(def ^:dynamic *conn* nil)

;; A unique URI for the in-memory database
(def test-db-uri "datomic:mem://my-app-test")

;; Your schema definition
(def schema
  [{:db/ident :user/email
    :db/valueType :db.type/string
    :db/cardinality :db.cardinality/one
    :db/unique :db.unique/identity}])

;; The test fixture
(defn with-clean-db [f]
  (d/create-database test-db-uri)
  (let [conn (d/connect test-db-uri)]
    (try
      (binding [*conn* conn]  ; Bind the connection for the test
        (d/transact *conn* schema) ; Install schema
        (f)) ; <-- Run the actual test function
      (finally
        (d/delete-database test-db-uri))))) ; <-- Guaranteed cleanup

;; Apply the fixture to every test in this namespace
(use-fixtures :each with-clean-db)

;; --- Your Tests ---

(deftest create-and-find-user
  (testing "A user can be created and retrieved"
    ;; Transact data into the clean database
    @(d/transact *conn* [{:user/email "test@example.com"}])

    ;; Query the database
    (let [db (d/db *conn*)
          user-id (d/q '[:find ?e . :where [?e :user/email "test@example.com"]] db)]
      (is (some? user-id) "User should be found in the database."))))

(deftest another-test
  (testing "The database is empty at the start of this test"
    (let [db (d/db *conn*)
          user-id (d/q '[:find ?e . :where [?e :user/email "test@example.com"]] db)]
      (is (nil? user-id) "Previous test's data should not exist."))))
#+end_src

**** How it Works:

 1.  *=with-clean-db= function*: This is your fixture. It takes a test function =f= as an argument.
 2.  *=d/create-database=*: Creates a new, empty in-memory database before the test runs.
 3.  *=binding=*: We use =binding= to make the =*conn*= var available within the dynamic scope of the test.
 4.  *=(f)=*: This executes the test body (e.g., the code inside =create-and-find-user=).
 5.  *=finally=*: This block is crucial. It /guarantees/ that =d/delete-database= is called, even if the test fails with an assertion error or an exception.
 6.  *=use-fixtures :each=*: This tells =clojure.test= to wrap every single =deftest= in this namespace with the =with-clean-db= fixture.

*** DONE Please help me define the concept of frontend UI testing in clojure.
    CLOSED: [2025-08-16 Sat 08:55]
    :LOGBOOK:
    - State "DONE"       from              [2025-08-16 Sat 08:55]
    :END:

 I think I am going to use playwright wrapper called `wally`. But having good library and ability to test UI is not enough. I am thinking
 about close integration with db - so I can define for example several test users with different access level and test UI using
 those various users and so to see how permissions affect the app. Also I think I always need to start from empty database and test
 each case in isolation, this should make it easier to write the tests. Also, may be I will check how UI actions affect the database -
 are users actually saved, etc...

 Can you provide a review of my plan? Is it reasonable or there are more options


 Excellent plan. You have identified the core principles of robust end-to-end (E2E) testing. This approach moves beyond simple UI interaction checking and into verifying the behavior of the entire system.

 Here is a review of your plan with additional suggestions:

**** Review of Your Plan

  1.  *DB Integration (User Roles):* *Excellent.* This is crucial for testing authorization logic. You're not just testing if a button exists, but if the /correct/ button exists for a given user.
  2.  *Test Isolation (Empty DB):* *Best Practice.* Starting each test from a known, clean state prevents cascading failures and makes tests deterministic and easier to debug.
  3.  *State Verification (Check DB):* *Essential.* This confirms that the UI is correctly wired to the backend. It closes the loop, verifying the full "cause and effect" of a user action.

  Your plan is not just reasonable; it's the right way to build a reliable E2E test suite.

**** More Options & Refinements

  Here are some established patterns in the Clojure ecosystem to implement your plan effectively.

  1.  *Use =clojure.test= Fixtures for Setup/Teardown:*
      =clojure.test= has a built-in mechanism for running setup and teardown code. This is the perfect place to manage your database state.

      #+begin_src clojure
      (use-fixtures :each (fn [f]
                           ;; 1. Start a transaction or clean the DB
                           (db/clear-all-tables!)
                           ;; 2. Run the actual test
                           (f)
                           ;; 3. Rollback the transaction
                           ))
      #+end_src

  2.  *Database State Management Strategy:*
      You have two primary options for the "clean DB" step:

      *   *Transaction Rollback (Preferred):* For databases that support it (like Postgres), wrap each test in a transaction and roll it back afterward. This is extremely fast and clean. You can implement this in your =:each= fixture.
      *   *DB Migration + Truncation:* For simpler databases (or as an alternative), use a library like [Migratus](https://github.com/yogthos/migratus) to set up the schema once, and then truncate all tables before each test. Slower, but very reliable.

  3.  *Data Seeding Helpers:*
      Abstract the creation of test data. Instead of writing raw SQL/Datalog in your tests, create helper functions. This makes tests more readable and maintainable.

      #+begin_src clojure
      (ns my-app.test.db-helpers)

      (defn create-user! [db-conn attrs]
        ;; logic to insert a user into the DB
        (d/transact! db-conn [[:db/add (d/tempid :db.part/user)
                              (merge {:user/email "test@example.com"} attrs)]]))

      ;; In your test:
      (create-user! *db* {:user/role :admin :user/name "Admin User"})
      #+end_src

  4.  *Page Object Model (POM):*
      This is a design pattern to make your =wally= code more organized. Create a namespace for each page or major component of your UI. This namespace will contain functions that hide the details of selectors and interactions.

      *   *Without POM:* =(w/fill "input#login-email" "test@example.com")=
      *   *With POM:* =(login-page/enter-email "test@example.com")=

      This separation makes tests easier to read and isolates changes. If a CSS selector changes, you only update it in one place (the page object) instead of many tests.

**** Example Test Structure

  #+begin_src clojure
  (ns my-app.login-test
    (:require [clojure.test :refer :all]
              [my-app.db :as db]
              [my-app.test.db-helpers :as th]
              [wally.core :as w]
              [my-app.test.pages.login :as login-page]))

  ;; Fixture to ensure a clean DB for every test
  (use-fixtures :each db/with-rollback-fixture)

  ;; Fixture to manage the browser instance
  (use-fixtures :once w/with-browser-fixture)

  (deftest admin-user-can-log-in
    (testing "An existing admin user can successfully log in and see the admin panel."
      ;; 1. Setup: Create the test user in the DB
      (th/create-user! db/*conn* {:user/email "admin@example.com" :user/role :admin})

      (w/with-page (w/new-page @w/browser)
        (login-page/goto)
        (login-page/login-as "admin@example.com" "password123")

        ;; 2. Assert: Check for UI changes
        (is (w/visible? "text=Admin Dashboard"))

        ;; 3. (Optional) Assert: Check for DB/session state changes
        ;; ...
        )))
  #+end_src

  Your approach is solid. By adding fixtures for lifecycle management and helper namespaces for data and UI interactions, you will create a powerful and maintainable test suite.
** DONE Fix [Login as] button in users list
   CLOSED: [2025-08-16 Sat 08:55]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-08-16 Sat 08:55]
   - State "TODO"       from              [2025-08-05 Tue 12:30]
   :END:

** DONE Testing frontend with Playwrite
   CLOSED: [2025-08-16 Sat 08:55] SCHEDULED: <2025-08-04 Mon>
   :LOGBOOK:
   - State "DONE"       from "WORKING"    [2025-08-16 Sat 08:55]
   - State "WORKING"    from "TODO"       [2025-08-04 Mon 23:25]
   - State "TODO"       from              [2025-08-04 Mon 23:25]
   :END:

*** Pages
 - https://github.com/pfeodrippe/wally
 - https://playwright.dev/docs/intro

** DONE nginx issues & correct config
   CLOSED: [2025-08-16 Sat 13:00]
   :LOGBOOK:
   - State "DONE"       from "WORKING"    [2025-08-16 Sat 13:00]
   - State "WORKING"    from              [2025-07-31 Thu 08:55]
   :END:

** DONE To finish before 1st deploy
   CLOSED: [2025-08-16 Sat 13:00]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-08-16 Sat 13:00]
   - State "TODO"       from "DONE"       [2025-08-16 Sat 13:00]
   - State "DONE"       from "TODO"       [2025-08-16 Sat 13:00]
   CLOCK: [2025-07-26 Sat 17:02]--[2025-07-26 Sat 17:02] =>  0:00
   - State "TODO"       from              [2025-07-26 Sat 12:05]
   :END:

*** DONE [#A] [Start meeting] button
    CLOSED: [2025-07-27 Sun 06:45]
    :LOGBOOK:
    - State "DONE"       from "WORKING"    [2025-07-27 Sun 06:45]
    CLOCK: [2025-07-27 Sun 06:46]--[2025-07-27 Sun 06:47] =>  0:01
    CLOCK: [2025-07-26 Sat 13:10]--[2025-07-26 Sat 13:13] =>  0:03
    - State "WORKING"    from "TODO"       [2025-07-26 Sat 13:10]
    - State "TODO"       from              [2025-07-26 Sat 12:05]
    :END:

- [X] Do not set status 'started' on 1st participant
- [X] Add button '[Start meeting'] on meeting screen, available only to staff users
- [X] Disallow switching topics when meeting is not started yet

*** DONE [#B] Run CI and build on GitHub - provide .jar as artifact
    CLOSED: [2025-07-27 Sun 11:05]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-27 Sun 11:05]
    - State "TODO"       from              [2025-07-26 Sat 12:15]
    :END:

*** DONE [#B] Provide deployment documentation [1/3]
    CLOSED: [2025-07-27 Sun 11:10]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-27 Sun 11:10]
    - State "TODO"       from              [2025-07-26 Sat 12:55]
    :END:

- [X] nginx config
- [ ] how to map resources?
- [ ] how to configure logging via xml

*** DONE team domains - auto add user to team
    CLOSED: [2025-07-27 Sun 13:45]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-27 Sun 13:45]
    - State "TODO"       from              [2025-07-27 Sun 06:45]
    :END:

*** DONE [#B] Document deployment process and requirements
    CLOSED: [2025-07-27 Sun 13:45]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-27 Sun 13:45]
    - State "TODO"       from              [2025-07-26 Sat 12:15]
    :END:

*** REJECTED [#D] Logging - configure correctly so it will save file ?
    CLOSED: [2025-07-27 Sun 13:45]
    :LOGBOOK:
    - State "REJECTED"   from "TODO"       [2025-07-27 Sun 13:45]
    - State "TODO"       from              [2025-07-26 Sat 12:10]
    :END:

*** DONE [#D] Sentry
    CLOSED: [2025-07-27 Sun 13:45]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-27 Sun 13:45]
    - State "TODO"       from              [2025-07-26 Sat 12:10]
    :END:

*** DONE [#A] my actions completion & notes button
    CLOSED: [2025-07-27 Sun 17:40]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-27 Sun 17:40]
    CLOCK: [2025-07-27 Sun 13:48]--[2025-07-27 Sun 17:38] =>  3:50
    - State "TODO"       from              [2025-07-26 Sat 22:55]
    :END:
*** DONE finish topic
    CLOSED: [2025-07-27 Sun 17:40]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-27 Sun 17:40]
    - State "TODO"       from              [2025-07-27 Sun 17:40]
    :END:
** TODO show optional block (under the control of staff) to show stage
   :LOGBOOK:
   - State "TODO"       from              [2025-08-16 Sat 14:00]
   :END:
** TODO show participants list on team
   :LOGBOOK:
   - State "TODO"       from              [2025-08-16 Sat 14:00]
   :END:
** WORKING [#B] Small bug fixes [2/2]
   :LOGBOOK:
   CLOCK: [2025-07-26 Sat 17:02]--[2025-07-26 Sat 22:45] =>  5:43
   - State "WORKING"    from "TODO"       [2025-07-26 Sat 13:15]
   CLOCK: [2025-07-26 Sat 13:13]--[2025-07-26 Sat 17:02] =>  3:49
   - State "TODO"       from "TODO"       [2025-07-26 Sat 12:15]
   - State "TODO"       from              [2025-07-26 Sat 12:15]
   :END:

- [X] forbid creation of a meetings in the past
- [X] hide action creation form after submit
- [ ] Profile - settings absent
- [ ] Project settings - shows some dialog, but nothing works.
- [ ] Past Meetings must work for finished meetings
- [ ] profile info to be displayed on meeting page (pass variable)

** TODO Meeting screen (the biggest part) [50%] [7/14]
   :PROPERTIES:
   :COOKIE_DATA: recursive
   :END:
   :LOGBOOK:
   - State "TODO"       from              [2025-07-21 Mon 22:10]
   :END:


*** DONE vote topic and other places - close SSE if its not needed
    CLOSED: [2025-07-24 Thu 21:35]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-24 Thu 21:35]
    - State "TODO"       from              [2025-07-24 Thu 21:20]
    :END:

*** WORKING [#A] re-render the whole screen individually by signal - screen changed.
    :LOGBOOK:
    CLOCK: [2025-07-24 Thu 22:01]--[2025-07-24 Thu 22:21] =>  0:20
    - State "WORKING"    from "TODO"       [2025-07-24 Thu 21:35]
    - State "TODO"       from              [2025-07-24 Thu 21:15]
    :END:

*** TODO [#A] finish topic
     :LOGBOOK:
     - State "TODO"       from              [2025-07-24 Thu 21:15]
     :END:

- [ ] save disucssion notes finally
- [ ] mark topic as finished, gray it out or strike out at left side

*** TODO [#B] save discussion notes every 10 secs
    :LOGBOOK:
    - State "TODO"       from              [2025-07-24 Thu 21:15]
    :END:

- [ ] save
- [ ] read from db on topic change

*** TODO [#C] support several meetings in parallel - split updates per meeting!
    :LOGBOOK:
    - State "TODO"       from              [2025-07-23 Wed 07:50]
    :END:

- my broadcast functions are working app-wide. and so if several meetings are going
  in parallel, it will affect each other!!! I need to pass the meeting ID to update
  only current meeting clients!

*** DONE Prepare to RND today
    CLOSED: [2025-07-23 Wed 21:15]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-23 Wed 21:15]
    - State "TODO"       from              [2025-07-23 Wed 07:20]
    :END:

- [X] Finish meeting - show confirmation, show meeting
- [X] Meetings page - display all recent meetings and their actions
- [X] "My Actions" page - display my pending actions from all various meetings
  - As a layout for this page, please use the HTML table with:
    - meeting topic
    - action topic
    - deadline
    - action status
- [ ] *maybe* would be good to start & finish timer
- [X] test that appX.koval.kharkov.ua works fine

*** DONE topics [100%]
    CLOSED: [2025-07-22 Tue 22:50]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-22 Tue 22:50]
    CLOCK: [2025-07-22 Tue 17:52]--[2025-07-22 Tue 22:48] =>  4:56
    - State "TODO"       from              [2025-07-21 Mon 22:10]
    :END:

- [X] Add topic
  - [X] clear input value after add!
- [X] Vote for topic
- [X] Delete topic (if it is not active or finished)
- [X] Set current topic (only for staff)
- [X] Meeting settings - votes are public
- [X] Make sure if voting is disabled, then we don't show the buttons and also backend checks

*** DONE Current topic
    CLOSED: [2025-07-23 Wed 21:20]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-23 Wed 21:20]
    - State "TODO"       from              [2025-07-21 Mon 22:20]
    :END:
**** DONE Actions
     CLOSED: [2025-07-23 Wed 21:20]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2025-07-23 Wed 21:20]
     - State "TODO"       from              [2025-07-21 Mon 22:20]
     :END:
***** DONE Add action
      CLOSED: [2025-07-23 Wed 21:20]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2025-07-23 Wed 21:20]
      - State "TODO"       from              [2025-07-21 Mon 22:20]
      :END:

***** DONE Display actions list
      CLOSED: [2025-07-23 Wed 21:20]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2025-07-23 Wed 21:20]
      - State "TODO"       from              [2025-07-21 Mon 22:20]
      :END:

**** TODO Discussion notes - allow to edit by anyone but lock when someone starts editing.... Good idea?
     :LOGBOOK:
     - State "TODO"       from              [2025-07-21 Mon 22:20]
     :END:

*** TODO timer
    :LOGBOOK:
    - State "TODO"       from              [2025-07-21 Mon 22:10]
    :END:

- [ ] SSE timer like in examples

*** TODO bugs and small fixes [/]
    :LOGBOOK:
    - State "TODO"       from              [2025-07-22 Tue 18:05]
    :END:

- [ ] validate meeting creation date - it should be in the future!

** TODO Admin settings & preferences [50%]
   :LOGBOOK:
   - State "TODO"       from              [2025-06-18 Wed 10:45]
   :END:
*** TODO App settings
    :LOGBOOK:
    - State "TODO"       from "TODO"       [2025-07-08 Tue 07:20]
    - State "TODO"       from              [2025-07-08 Tue 07:20]
    :END:
*** DONE List users (separate page) (for admin)
    CLOSED: [2025-07-08 Tue 07:20]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-07-08 Tue 07:20]
    - State "TODO"       from              [2025-06-18 Wed 10:25]
    :END:
**** DONE Change access level to manager (as admin)
     CLOSED: [2025-07-04 Fri 23:45]
     :LOGBOOK:
     - State "DONE"       from "TODO"       [2025-07-04 Fri 23:45]
     - State "TODO"       from              [2025-06-18 Wed 10:25]
     :END:
** TODO Change theme
   :LOGBOOK:
   - State "TODO"       from              [2025-07-05 Sat 22:55]
   :END:

** TODO First App screen [38%]
   :LOGBOOK:
   - State "TODO"       from              [2025-06-18 Wed 10:45]
   :END:
*** TODO redirect if user already logged in
    :LOGBOOK:
    - State "TODO"       from              [2025-06-28 Sat 12:35]
    :END:
*** DONE config
    CLOSED: [2025-06-22 Sun 16:05]
    :LOGBOOK:
    - State "DONE"       from "WORKING"    [2025-06-22 Sun 16:05]
    CLOCK: [2025-06-21 Sat 08:37]--[2025-06-21 Sat 08:52] =>  0:15
    CLOCK: [2025-06-21 Sat 07:02]--[2025-06-21 Sat 07:13] =>  0:11
    CLOCK: [2025-06-20 Fri 08:10]--[2025-06-20 Fri 08:54] =>  0:44
    - State "WORKING"    from "TODO"       [2025-06-19 Thu 07:50]
    - State "TODO"       from              [2025-06-19 Thu 07:50]
    :END:
https://github.com/juxt/aero
*** DONE ring-oauth2/ring-oauth2
    CLOSED: [2025-06-22 Sun 16:05]
    :LOGBOOK:
    - State "DONE"       from              [2025-06-22 Sun 16:05]
    :END:
https://github.com/weavejester/ring-oauth2
*** DONE Implement "fake" login
    CLOSED: [2025-06-27 Fri 09:05]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2025-06-27 Fri 09:05]
    CLOCK: [2025-06-24 Tue 08:44]--[2025-06-24 Tue 08:44] =>  0:00
    - State "TODO"       from              [2025-06-24 Tue 08:10]
    :END:

- [X] Use random fake data (use some faker module)
- [X] Display button on dev-mode only
- [ ] implement 'post' action for fake login
  - 4xx for invalid (non-localhost) request

*** DONE Implement Sign In with Google / oauth2 std.
    CLOSED: [2025-06-27 Fri 09:10]
    :LOGBOOK:
    - State "DONE"       from "WORKING"    [2025-06-27 Fri 09:10]
    CLOCK: [2025-06-24 Tue 08:44]--[2025-06-24 Tue 10:09] =>  1:25
    CLOCK: [2025-06-22 Sun 16:07]--[2025-06-22 Sun 16:27] =>  0:20
    - State "WORKING"    from "TODO"       [2025-06-22 Sun 16:05]
    - State "TODO"       from              [2025-06-18 Wed 10:20]
    :END:

- [X] implement sign in with ~bulma~ button done:[2025-06-22 Sun 16:15]
- [X] change title from "Welcome to Bulma"

*** TODO Add top menu
    :LOGBOOK:
    - State "TODO"       from              [2025-06-18 Wed 10:20]
    :END:
*** TODO Run tests in parallel like in ~biff~
    :LOGBOOK:
    - State "TODO"       from              [2025-06-24 Tue 08:10]
    :END:

*** TODO try to use JS button version of google login
    :LOGBOOK:
    - State "TODO"       from              [2025-06-27 Fri 09:10]
    :END:

- [ ] comment out ~Bulma~ button and use /google js version/
  - following https://developers.google.com/identity/gsi/web/guides/display-button

*** REJECTED Implement Sign In with Jira (lets do it in next round, if needed!)
    CLOSED: [2025-06-22 Sun 16:05]
    :LOGBOOK:
    - State "REJECTED"   from "TODO"       [2025-06-22 Sun 16:05]
    - State "TODO"       from              [2025-06-18 Wed 10:20]
    :END:
*** TODO Add help / from markdown as usual
*** TODO List past meetings
    :LOGBOOK:
    - State "TODO"       from              [2025-06-18 Wed 10:25]
    :END:
*** TODO Make some user admin (from cli, after registration)
    :LOGBOOK:
    - State "TODO"       from              [2025-06-18 Wed 10:25]
    :END:
** DONE [#A] Join meeting
   CLOSED: [2025-07-17 Thu 11:20]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2025-07-17 Thu 11:20]
   - State "TODO"       from              [2025-07-17 Thu 08:10]
   :END:

   1) [X] Check that user can join this team meetings
   2) [X] Create "participants" table for the meeting:
      1) user id
      2) meeting id
      3) join time
   3) [X] Create record in participants table
   4) [X] Redirect to main meeting screen

** TODO Make sure to enable gzip or even better: brothli compression
   :LOGBOOK:
   - State "TODO"       from              [2025-06-15 Sun 20:55]
   :END:

   https://andersmurphy.com/2025/04/15/why-you-should-use-brotli-sse.html

** TODO Populate Actions Assigned/Resolved on users list
   :LOGBOOK:
   - State "TODO"       from              [2025-07-08 Tue 07:20]
   :END:
** TODO Populate main page statistics & recent activity
   :LOGBOOK:
   - State "TODO"       from              [2025-07-08 Tue 07:25]
   :END:
** IDEA Future ideas
   :LOGBOOK:
   - State "IDEA"       from              [2025-07-04 Fri 23:45]
   :END:
- [ ] add gravatar/auto generated icon
- [ ] auto tests
- [ ] UI tests via https://github.com/ryrobes/rabbitize
- [ ] gitlab/github CI?
- [ ] manage/search users - commented out for now
- [ ] auto add team to selected list for user after creation via modal

