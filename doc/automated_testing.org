* Running Tests

This project includes several types of tests that can be run individually or together.

** Standard Unit Tests

Run all unit tests (non-UI) using the standard test alias:
#+begin_src bash
# Run all unit tests
clj -M:test

# Run specific test namespace
clj -M:test -n my-app.core-test

# Run tests matching a pattern
clj -M:test -v my-app.db-test/create-user-test
#+end_src

** Watch Mode Tests

For continuous testing during development, use the test-watch alias:
#+begin_src bash
# Run tests in watch mode (reruns on file changes)
clj -M:test-watch
#+end_src

** UI Tests (Playwright/Wally)

UI tests use Playwright through the Wally wrapper for browser automation:

#+begin_src bash
# Run all UI tests (headless browser mode)
clj -M:test-ui

# Run specific UI test namespace
clj -M:test-ui -n ok.hola-tact-meet.fake-login-test-page

# Run specific UI test namespace (admin tests)
clj -M:test-ui -n ok.hola-tact-meet.admin-users-page-test
#+end_src

*** UI Test Requirements
- Requires a running test server on port 8082 (started automatically by test fixtures)
- Uses in-memory Datomic database for isolation
- Runs in headless browser mode for CI/CD compatibility
- Each test starts with a clean database state

*** Individual UI Test Examples

#+begin_src bash
# Test fake login functionality
clj -M:test-ui -n ok.hola-tact-meet.fake-login-test-page

# Test admin user management
clj -M:test-ui -n ok.hola-tact-meet.admin-users-page-test

# Test basic UI navigation
clj -M:test-ui -n ok.hola-tact-meet.basic-ui-test
#+end_src

*** Running Individual Test Functions

You can also run specific test functions using the -v flag:
#+begin_src bash
# Run a specific test function
clj -M:test-ui -v ok.hola-tact-meet.fake-login-test-page/create-fake-admin-user-test

# Run multiple specific tests
clj -M:test-ui -v ok.hola-tact-meet.fake-login-test-page/create-fake-admin-user-test \
                   ok.hola-tact-meet.fake-login-test-page/create-fake-staff-user-test
#+end_src

** Test Development Workflow

*** Interactive Testing in REPL
For developing and debugging tests, use CIDER in Emacs:

1. Start REPL with the appropriate alias:
   - For unit tests: =cider-jack-in= with =clj -M:dev=
   - For UI tests: =cider-jack-in= with =clj -M:dev= (includes Wally dependencies)

2. Evaluate test functions interactively using the comment blocks in test files

3. Use the helper functions in =common.clj= for test setup:
   #+begin_src clojure
   ;; Start test server
   (common/start-test-server!)

   ;; Navigate to page (browser starts automatically)
   (navigate-to-fake-login-page)

   ;; Test interactions
   (get-page-title)

   ;; Clean up
   (common/stop-test-server!)
   #+end_src

*** Test Server Management
UI tests automatically manage a test server on port 8082:
- Uses in-memory Datomic database (=memory://test-meetings=)
- Fresh database for each test run
- Server starts automatically when needed
- Uses Aero test profile for configuration

*** Debugging Failed Tests
When UI tests fail:
1. Check if the test server is running correctly
2. Verify page elements exist (selectors might have changed)
3. Use REPL for interactive debugging with the comment blocks
4. Check browser console for JavaScript errors (when testing in non-headless mode)

* How to use Wally selectors

Wally is a Clojure Playwright wrapper for browser automation testing. It provides multiple ways to select and interact
with web elements.

** Core API Functions

*** Navigation & Interaction
#+begin_src clojure
;; Basic navigation and interaction
(w/navigate "http://localhost:8081")       ; Navigate to URL
(w/click selector)                         ; Click element
(w/fill selector "text")                   ; Fill form field
(w/keyboard-press "Enter")                 ; Simulate keyboard press

;; Browser session management
;; Browser starts automatically on first Wally command (e.g., w/navigate)
;; Browser lifecycle is managed automatically by Playwright
#+end_src

*** Element Querying
#+begin_src clojure
;; Query elements
(w/-query selector)                        ; Find single element
(w/is-visible? selector)                   ; Check visibility
(w/get-page)                              ; Get Playwright page object

;; Get element content
(.textContent (w/-query "h1.title"))      ; Get text content
#+end_src

** Selector Types

*** 1. String Selectors (CSS)
Most straightforward for simple selections:
#+begin_src clojure
;; CSS selectors
(w/-query "h1.title")                     ; Class selector
(w/-query "#user-table")                  ; ID selector
(w/-query "tbody tr")                     ; Element selector
(w/-query "td:nth-child(3)")             ; Pseudo selector
(w/-query "button.is-danger")            ; Combined selectors
(w/-query "a[href*='teams']")            ; Attribute selector
#+end_src

*** 2. Wally Selectors (ws/)
Special selectors for text-based matching:
#+begin_src clojure
(require '[wally.selectors :as ws])

;; Text-based selection (must use vector syntax)
(w/-query [(ws/text "Copy")])                    ; Find by text content
(w/-query [(ws/text "Manage Users")])            ; Find by exact text
(w/-query [(ws/text "Copy") (ws/nth= "1")])     ; Combined: text + nth occurrence

;; Common pattern from wally-example
(w/click [(ws/text "Copy") (ws/nth= "1")])
#+end_src

*** 3. Garden Selectors (s/)
For more complex programmatic selector building:
#+begin_src clojure
(require '[garden.selectors :as s])

;; Attribute-based selection
(w/click (s/a (s/attr= :href "/login/fake")))    ; Link by href attribute
(w/fill (s/input (s/attr= :type "email")))      ; Input by type

;; Programmatic selector building
(s/div (s/class :column))                        ; div.column
(s/h1 (s/class :title))                         ; h1.title
#+end_src

** Testing Patterns

*** Page Object Model Example
#+begin_src clojure
;; Define page interactions as functions
(defn navigate-to-users-page []
  (w/navigate (str APP_URL "admin/manage-users")))

(defn get-page-title []
  (.textContent (w/-query "h1.title")))

(defn get-first-user-email []
  (.textContent (w/-query "tbody tr td:nth-child(2)")))

(defn click-first-user-toggle []
  (w/click "tbody tr button"))
#+end_src

*** REPL-Driven Development
#+begin_src clojure
(comment
  ;; Interactive development workflow

  ;; 1. Start browser
  (w/start-browser!)

  ;; 2. Navigate and setup
  (w/navigate "http://localhost:8081")
  (w/click (s/a (s/attr= :href "/login/fake")))

  ;; 3. Test selectors interactively
  (w/-query "h1.title")                    ; Find element
  (.textContent (w/-query "h1.title"))     ; Get text
  (w/is-visible? "table.table")           ; Check visibility

  ;; 4. Test interactions
  (w/click "button.button")
  (w/fill "#search" "test query")

  ;; 5. Clean up
  (w/stop-browser!)
  )
#+end_src

*** Common Gotchas & Solutions

**** Issue: Function not found errors
#+begin_src clojure
;; ❌ WRONG - These functions don't exist
(w/get-text "selector")         ; No such function
(w/-query-all "selector")       ; No such function
(w/-query-from element "sel")   ; No such function

;; ✅ CORRECT - Use these instead
(.textContent (w/-query "selector"))              ; Get text
(w/-query "selector")                            ; Get first element
(w/-query "parent-sel child-sel")               ; Query within element
#+end_src

**** Issue: Selector syntax errors
#+begin_src clojure
;; ❌ WRONG - Wally selectors need vector syntax
(w/-query (ws/text "Copy"))

;; ✅ CORRECT - Use vector for wally selectors
(w/-query [(ws/text "Copy")])

;; ❌ WRONG - Garden selectors in vectors
(w/-query [(s/a (s/attr= :href "/login"))])

;; ✅ CORRECT - Garden selectors direct
(w/click (s/a (s/attr= :href "/login")))
#+end_src

**** Issue: Element not found
#+begin_src clojure
;; Add visibility checks and waits
(when (w/is-visible? "table.table")
  (w/click "tbody tr button"))

;; Use more specific selectors
(w/-query "div.modal.is-active")          ; More specific
(w/-query ".modal")                       ; Less specific
#+end_src

** Example: Complete Admin Users Test
#+begin_src clojure
(deftest ^:ui admin-users-page-test
  (testing "Admin users page functionality"
    (w/with-browser
      ;; Login
      (w/navigate APP_URL)
      (w/click (s/a (s/attr= :href "/login/fake")))

      ;; Navigate to admin page
      (w/navigate (str APP_URL "admin/manage-users"))

      ;; Verify page loaded
      (is (= "Manage Users" (.textContent (w/-query "h1.title"))))
      (is (w/is-visible? "table.table"))

      ;; Test user data
      (let [first-user-email (.textContent (w/-query "tbody tr td:nth-child(2)"))]
        (is (clojure.string/includes? first-user-email "@")))

      ;; Test interactions
      (w/click "tbody tr button")           ; Click toggle
      (w/click [(ws/text "Manage Teams")])  ; Click by text
      )))
#+end_src
* Problems (to fix later, upstream)

 Wally is completely ignoring all our JVM property configurations and hardcoded to use
 Chrome with a specific data directory. This is why it keeps opening tabs in your existing Chrome browser.

 The fundamental issue: Wally version 0.0.4 appears to have hardcoded browser settings that override JVM
 properties.

 Final Solution: Accept the Limitation

 Given wally's behavior, the most practical approach is:

 Workflow A: Sequential (Recommended)

 # 1. REPL Development (with visible browser)
 clj -M:test-server

 # 2. When you want to run tests:
 # In REPL: (let [current-page (w/get-page)] (.close (.context current-page)))
 # Then run tests:
 clj -M:test-ui

 # 3. Restart REPL when needed

 Workflow B: Separate Terminals

 - Terminal 1: REPL development (clj -M:test-server)
 - Terminal 2: Tests only (close REPL browser first, then clj -M:test-ui)

 Workflow C: Test-First Development

 - Write/run tests first: clj -M:test-ui
 - Then do REPL debugging: clj -M:test-server

 The reality: Wally 0.0.4 is designed as a single-browser-instance tool, not for parallel workflows. This is
 actually common with browser automation tools - they're designed to own the browser completely.

 Recommended approach for your workflow:
 1. Use (common/pause-repl-browser!) when you want to test
 2. Run clj -M:test-ui
 3. Restart REPL process to resume development

 This gives you the best of both worlds without fighting against wally's architecture.

